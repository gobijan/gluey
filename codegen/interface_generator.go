package codegen

import (
	"fmt"
	"os"
	"path/filepath"

	"gluey.dev/gluey/expr"
)

// InterfaceGenerator generates only interfaces and contracts.
// This is used by the 'gen' command and never touches user code.
type InterfaceGenerator struct {
	app     *expr.AppExpr
	outDir  string
}

// NewInterfaceGenerator creates a new interface generator.
func NewInterfaceGenerator(app *expr.AppExpr, outDir string) *InterfaceGenerator {
	return &InterfaceGenerator{
		app:    app,
		outDir: outDir,
	}
}

// Generate generates all interfaces and contracts.
func (g *InterfaceGenerator) Generate() error {
	// Create output directories
	dirs := []string{
		filepath.Join(g.outDir, "interfaces"),
		filepath.Join(g.outDir, "types"),
		filepath.Join(g.outDir, "http"),
	}
	
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}
	
	// Generate controller interfaces
	if err := g.generateControllerInterfaces(); err != nil {
		return fmt.Errorf("failed to generate controller interfaces: %w", err)
	}
	
	// Generate types (forms and models)
	if err := g.generateTypes(); err != nil {
		return fmt.Errorf("failed to generate types: %w", err)
	}
	
	// Generate HTTP router
	if err := g.generateRouter(); err != nil {
		return fmt.Errorf("failed to generate router: %w", err)
	}
	
	return nil
}

// generateControllerInterfaces generates controller interface files.
func (g *InterfaceGenerator) generateControllerInterfaces() error {
	// Generate a controller interface for each resource
	for _, resource := range g.app.Resources {
		content := g.generateResourceInterface(resource)
		
		filename := filepath.Join(g.outDir, "interfaces", resource.Name + "_controller.go")
		if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
			return err
		}
	}
	
	// Generate pages controller if there are pages
	if len(g.app.Pages) > 0 {
		content := g.generatePagesInterface()
		
		filename := filepath.Join(g.outDir, "interfaces", "pages_controller.go")
		if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
			return err
		}
	}
	
	return nil
}

// generateResourceInterface generates a controller interface for a resource.
func (g *InterfaceGenerator) generateResourceInterface(resource *expr.ResourceExpr) string {
	code := "package interfaces\n\n"
	code += "// Generated by Gluey - DO NOT EDIT\n\n"
	code += "import \"net/http\"\n\n"
	
	controllerName := toTitle(resource.Name) + "Controller"
	
	code += fmt.Sprintf("// %s handles requests for %s resources.\n", controllerName, resource.Name)
	code += fmt.Sprintf("type %s interface {\n", controllerName)
	
	// Generate method signatures for each action
	for _, action := range resource.Actions {
		comment := getActionComment(action, resource.Name)
		code += fmt.Sprintf("\t// %s\n", comment)
		code += fmt.Sprintf("\t%s(w http.ResponseWriter, r *http.Request)\n", toTitle(action))
		
		if action != resource.Actions[len(resource.Actions)-1] {
			code += "\n"
		}
	}
	
	code += "}\n"
	
	return code
}

// generatePagesInterface generates the pages controller interface.
func (g *InterfaceGenerator) generatePagesInterface() string {
	code := "package interfaces\n\n"
	code += "// Generated by Gluey - DO NOT EDIT\n\n"
	code += "import \"net/http\"\n\n"
	code += "// PagesController handles static page requests.\n"
	code += "type PagesController interface {\n"
	
	for i, page := range g.app.Pages {
		for j, route := range page.Routes {
			methodName := toTitle(page.Name)
			if route.Method != "GET" {
				methodName += toTitle(route.Method)
			}
			
			comment := fmt.Sprintf("%s handles %s %s", methodName, route.Method, route.Path)
			code += fmt.Sprintf("\t// %s\n", comment)
			code += fmt.Sprintf("\t%s(w http.ResponseWriter, r *http.Request)\n", methodName)
			
			if i < len(g.app.Pages)-1 || j < len(page.Routes)-1 {
				code += "\n"
			}
		}
	}
	
	code += "}\n"
	
	return code
}

// generateTypes generates form and model types.
func (g *InterfaceGenerator) generateTypes() error {
	gen := NewTypesGenerator(g.app)
	content, err := gen.Generate()
	if err != nil {
		return err
	}
	
	// Change package name to "types"
	content = "package types\n" + content[len("package "+g.app.Name+"\n"):]
	
	filename := filepath.Join(g.outDir, "types", "forms.go")
	return os.WriteFile(filename, []byte(content), 0644)
}

// generateRouter generates the HTTP router.
func (g *InterfaceGenerator) generateRouter() error {
	content := g.generateRouterContent()
	
	filename := filepath.Join(g.outDir, "http", "router.go")
	return os.WriteFile(filename, []byte(content), 0644)
}

// generateRouterContent generates router content.
func (g *InterfaceGenerator) generateRouterContent() string {
	code := "package http\n\n"
	code += "// Generated by Gluey - DO NOT EDIT\n\n"
	code += "import (\n"
	code += "\t\"net/http\"\n"
	code += fmt.Sprintf("\t\"%s/gen/interfaces\"\n", g.app.Name)
	code += ")\n\n"
	
	// Generate Controllers struct
	code += "// Controllers holds all controller implementations.\n"
	code += "type Controllers struct {\n"
	
	for _, resource := range g.app.Resources {
		controllerName := toTitle(resource.Name) + "Controller"
		code += fmt.Sprintf("\t%s interfaces.%s\n", toTitle(resource.Name), controllerName)
	}
	
	if len(g.app.Pages) > 0 {
		code += "\tPages interfaces.PagesController\n"
	}
	
	code += "}\n\n"
	
	// Generate MountRoutes function
	code += "// MountRoutes mounts all routes on the given mux.\n"
	code += "func MountRoutes(mux *http.ServeMux, c Controllers) {\n"
	
	// Register routes in proper order to avoid conflicts
	// More specific routes first
	for _, resource := range g.app.Resources {
		g.addResourceRoutes(&code, resource)
	}
	
	// Page routes (non-root first)
	for _, page := range g.app.Pages {
		hasRootRoute := false
		for _, route := range page.Routes {
			if route.Path == "/" {
				hasRootRoute = true
				break
			}
		}
		if !hasRootRoute {
			g.addPageRoute(&code, page)
		}
	}
	
	// Static files
	code += "\t// Static files\n"
	code += "\tmux.Handle(\"GET /static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"public\"))))\n"
	code += "\n"
	
	// Root route last
	for _, page := range g.app.Pages {
		for _, route := range page.Routes {
			if route.Path == "/" {
				g.addPageRoute(&code, page)
				break
			}
		}
	}
	
	code += "}\n"
	
	return code
}

// addResourceRoutes adds resource routes to the router code.
func (g *InterfaceGenerator) addResourceRoutes(code *string, resource *expr.ResourceExpr) {
	controllerVar := "c." + toTitle(resource.Name)
	basePath := "/" + resource.Name
	
	*code += fmt.Sprintf("\t// %s routes\n", toTitle(resource.Name))
	
	// Order matters for Go 1.22+ routing
	// More specific paths first
	*code += fmt.Sprintf("\tmux.HandleFunc(\"GET %s/new\", %s.New)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"GET %s/{id}/edit\", %s.Edit)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"GET %s/{id}\", %s.Show)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"POST %s/{id}/delete\", %s.Destroy)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"POST %s/{id}\", %s.Update)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"GET %s\", %s.Index)\n", basePath, controllerVar)
	*code += fmt.Sprintf("\tmux.HandleFunc(\"POST %s\", %s.Create)\n", basePath, controllerVar)
	*code += "\n"
}

// addPageRoute adds a page route to the router code.
func (g *InterfaceGenerator) addPageRoute(code *string, page *expr.PageExpr) {
	for _, route := range page.Routes {
		methodName := toTitle(page.Name)
		if route.Method != "GET" {
			methodName += toTitle(route.Method)
		}
		
		*code += fmt.Sprintf("\tmux.HandleFunc(\"%s %s\", c.Pages.%s)\n", 
			route.Method, route.Path, methodName)
	}
}

// getActionComment returns a descriptive comment for an action.
func getActionComment(action, resourceName string) string {
	switch action {
	case "index":
		return fmt.Sprintf("Index displays a list of %s", resourceName)
	case "show":
		return fmt.Sprintf("Show displays a single %s", resourceName)
	case "new":
		return fmt.Sprintf("New displays the form for creating a new %s", resourceName)
	case "create":
		return fmt.Sprintf("Create handles the creation of a new %s", resourceName)
	case "edit":
		return fmt.Sprintf("Edit displays the form for editing a %s", resourceName)
	case "update":
		return fmt.Sprintf("Update handles updating a %s", resourceName)
	case "destroy":
		return fmt.Sprintf("Destroy handles deleting a %s", resourceName)
	default:
		return fmt.Sprintf("%s handles the %s action", toTitle(action), action)
	}
}

// toTitle converts a string to title case.
func toTitle(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(s[0]-32) + s[1:]
}